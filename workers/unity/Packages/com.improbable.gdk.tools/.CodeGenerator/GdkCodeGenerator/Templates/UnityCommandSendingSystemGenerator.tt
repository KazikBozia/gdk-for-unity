<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#
    var generatedHeader = CommonGeneratorUtils.GetGeneratedHeader();
#>
<#= generatedHeader #>

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Unity.Entities;
using Improbable.Gdk.Core;
using Improbable.Gdk.Core.Commands;
using Improbable.Gdk.GameObjectRepresentation;
using Improbable.Worker;

namespace Improbable.Gdk.Generated
{
    public class CommandSendingSystem : ComponentSystem
    {
        public Entity WorkerEntity;

        public EntityManager EntityMgr => this.EntityManager;

        private readonly Dictionary<Type, Func<EntityManager, global::Unity.Entities.Entity, object, EntityId, object, object, uint?, bool, long>> internalCommandHandlers = new Dictionary<Type, Func<EntityManager, global::Unity.Entities.Entity, object, EntityId, object, object, uint?, bool, long>>();

        protected override void OnCreateManager()
        {
            base.OnCreateManager();

            WorkerEntity = World.GetExistingManager<WorkerSystem>().WorkerEntity;
            this.Enabled = false;
            RegisterAllTypes();
        }

        protected override void OnUpdate()
        {
        }

        public long SendCommand<TCommand, TRequest, TResponse>(
            CommandTypeInformation<TCommand, TRequest, TResponse> typeInformation,
            EntityId entityId, TRequest request, Action<TResponse> callback, uint? timeoutMillis,
            bool allowShortCircuiting)
            where TRequest: struct
            where TResponse: struct, IReceivedResponse
        {
            if (!internalCommandHandlers.TryGetValue(typeInformation.GetType(), out var func))
            {
                throw new ArgumentException("NO");
            }

            return func(EntityMgr, WorkerEntity, typeInformation, entityId, request, callback, timeoutMillis, allowShortCircuiting);
        }

        private void RegisterAllTypes()
        {
            var types = AppDomain.CurrentDomain.GetAssemblies().SelectMany(ass => ass.GetTypes()).Where(typ =>
                typeof(ISpecialCommandSender).IsAssignableFrom(typ) && !typ.IsAbstract);
            foreach (var typ in types)
            {
                var sender = (ISpecialCommandSender) Activator.CreateInstance(typ);
                sender.RegisterSelf(internalCommandHandlers);
            }
        }
    }
}
